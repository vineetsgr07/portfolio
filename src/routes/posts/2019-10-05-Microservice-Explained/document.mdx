import naviLogo from './navi-logo.svg'
import reactLogo from './react-logo.svg'
import styles from './document.module.css'

<div className={styles["Welcome"]}>
  {/* <img src={naviLogo} className={styles["logo-navi"]} alt="logo" /> */}
  {/* <img src={reactLogo} className={styles["logo-react"]} alt="logo" /> */}
</div>


## Introduction: 
<div className={styles["justifyContent"]}>
This is an article which mainly focusses on designing the Microservice architecture, when your Monolithic application start 
getting complex with lot of new feature, bussiness logic and you want to make it Robust, Reliable and compatible whitout 
comprimising it's latency and concurency. 
let's disscuss when you should start re-defining your monolithic design into microservices and move the bussiness logic by 
by decomposing it into different services. What are all design pattern you should refer to structure your microservice, 
Why Domain Driven Development and why it is the best choise for microservices. 
How microsercie comunicate using one-to and one-to-many with other services in it's ecosystem. What is messge brocker 
and it's type. What is saga pattern and how it is helpfull to maintain concurency across the services.
</div>

# Monolithic Vs MicroserviceÂ 
<div className={styles["justifyContent"]}>
<b>Monolithic</b> In past we have been using monolithic architecutre where all the logic is composed in one, consider a logistic system 
where we have
Let's consider these 5 modules, Inventory Management, Transport Management, Packaging Management, Facility Location and 
Customer servies.
All these module are part of a big logistics application and they communicate via their seperate services.
As the company grow, feature also grow which makes the application bulky. Suppose this application is developed using 
a particular language with old version and with time the language gets outdated, it's going to be very difficult to update 
the the whole application and if company decided to update the language then development going to be affected which can cost
millions of loss to the company.
Also how diffucult it going to be for the developer to maintain and add a new feature, everytime they have to inform the whole dev 
team to stop their development until their feature goes live, again this can be solved via Git but it's going to be painful 
to do pull, rebase and merge again and again. Developer productivity going to be affected very badly.
Monolithic architecture means everything is composed in one. 

<br/>
<br/>

<b>Microservice</b> all diferent services works as a distributed system. One way to solve the above problem is to decompose 
these module as different services and host them on different server. This will sove the probelm of programming langiage getting 
outdated. Also if a new programming language comes to market and development team wants to refactor their code they
can do it easily without affecting any other modeuls.  When decomposing a monolithic into microservice, we should be 
considering the business logic not the technical complexity. Finding the main classes in the monolithic and make them services. 
Reason for decomposing a monolithic application is to atain scalibility, reliability and security. Also maintainibility, 
testibility and deploybility.Microservices is a set of loosely coupled services. Individual services across a microservice 
use Rest Api or asynchronous messaging to do inter process communication. We will be discussing more in-depth about the 
asynchronoud messaging in this series of article.

  There are two pattern for decomposition.

  1) Decomposition by capability

  2) Decomposition by Sub domain. DDD

InterProcess communication can be of two types. Synchronous and Ashynchronous. In Synchronous we can think it as a one to one 
communication where client send a request to server and wats for the response, Where as in an many to many could be of two types
Publish/Subscribe: Client publish and server subscribe to it for the changes it want to recieve
Publish/async response: 
</div>

grpc/ Rest API:
Docker/Kubernetes: It provide service registry and service discovery mechanism

message brocker is used for communicating between two services. uses brockerless and brocker based.

In brocker based, sender doesn't need to know the location of the consumer. ALso brocker buffer the data until consumer ready to
accept it.

1) Active MQ

2) Rabit MQ

3) Apache Kafka

Could based:

1) Aws Kinesis
2) AWS SQS

messaging Standalone -> AMQP and STOMP does message brocker support. messaging ordering, delivery gaurantee, persistence, durability
scalability, latency, competing consumers

Handeling duplicate message: 
Lets take an account of grocery delivery system. client create a order and followed by cancelling the same order. let suppose order 
placed didn't acknowlede. and it tries again and it created the order again. 
Two ways to handle it

1) Write idempotent message handler
2) Track message and discard duplicate



# Load Balencer
How Load balancer is set up and how to scale an application 

# Domain Driven Development

# Sagas

Saga us a design patter which is used to maintain consistency in distributed system. Given an example where you put series of
transaction is affected by previous transaction . current tansaction is affected by previous one. Think of a example like logistic 
food delivery system or any other.

Two ways to deal with messaging transaction
1) Choreography:
2) orchestration:

Choreography is a pub/sub event babsed saga. for example if a service has to use three other service it will publish the events
and subscribe to those services to get the desired result.

Orchastration: It uses orchastration class to tell each saga about their responsibility.
 It communicate using command/asyn reply-stype interation. 
 It's usefull to mode a saga as a state machine as it describe all possible scenarious. Testing Sagas

 Pivot Transaction.


 Aggregate: Take an example of an logistic company, which consist of fleet system, facility system, delivery system. Fist mile,
 mid mile and last mile. All these are noun.
 Patter aggregation: Organise a domain model as a collection of Aggregates, each of which is a group of objects that can be treated
 as a unit.











<!--
Reference: 
1. https://codeburst.io/throttling-and-debouncing-in-javascript-b01cad5c8edf -->